### 1. 특징

`1) 포스트그레스큐엘이란?`

포스트그레스큐엘이란 오라클, MYSQL, MSSQL과 같은 관계형 데이터베이스 메니지먼트 시스템입니다.

`2) 역사`

역사를 알아보겠습니다. 1977년 미국 UC버클리 대학에서 만들어진 IngresDB가 포스트그레스큐엘의 토대가 되었다고 할 수 있습니다. IngresDB는 대규모 애플리케이션을 지원하기 위해 개발되었다가, 모종의 이유로 1993년 서비스를 종료했습니다. 이것을 계승한 것이 오늘날의 포스트그레스큐엘입니다.

`3) 키워드`

다음은 키워드로 포스트그레스큐엘의 특징을 알아보겠습니다. 먼저 휴대성, 다양한 플랫폼과 표준 규격의 SQL을 지원합니다.

다음은 신뢰성입니다. 사용자가 어떤 의도된 동작을 명령하면 DB에서 요구된 기능을 잘 수행해줘야 하겠죠. 이를 위해 원자성, 일관성, 고립성, 지속성과 트랜잭션을 지원합니다.

MVCC란 다중 버전 동시성 제어이며, 동시 접근을 허용하는 방법 중 하나입니다. 일반적으로 읽기 작업과 쓰기 작업이 동일한 데이터에 동시 접근을 하면 해당 데이터에 대한 잠금이 발생하게 되겠죠. MVCC는 이를 방지하기 위한 메커니즘이라고 할 수 있습니다. 동일한 데이터에 대한 수정과 검색이 동시에 일어났을 때, 거울을 비추는 것처럼 해당 데이터에 대한 스냅샷이라는 것을 제시합니다. 그러면 쓰기 세션과 읽기 세션은 스냅샷 데이터를 토대로 각자의 작업을 할 수 있겠습니다. 이때 쓰기 세션에서 일어나는 수정 사항은 UNDO라는 영역에 버전 사항이 저장됩니다. 인텔리제이 local history에서 코드 수정 사항이 순차적으로 적재되는 것을 생각하시면 되겠습니다. 수정이 끝나면 최신 변경된 내용이 데이터에 기록되고, 읽기 세션은 접근 시점의 최근 버전의 데이터를 읽게 됩니다.

로우 레벨 락킹은 행 수준 잠금이라는 뜻입니다. 테이블 수준 잠금보다 더 작은 단위고, 동시 접근이 일어났을 때 테이블 단위보다 행 단위로 잠금이 된다면 동시성 면에서 더 유리하겠습니다.

그리고 다양한 인덱싱 기법을 지원하며, Full-text Search 기능을 지원합니다. Full-text Search는 긴 문자열에서 검색이 용이하도록, 데이터 내용을 단어로 쪼개 전처리하는 것을 뜻합니다.

또 다양한 프로시저와 인터페이스를 지원합니다.

다음은 확장성입니다. 행을 나누는 테이블 파티셔닝과, 테이블 스페이스 기능이 구현되어 있습니다.

다음은 보안입니다. 데이터 암호화, 접근 제어, 로그 감사를 제공하며 사용자의 접속을 인증하는 과정을 거치고, 테이블, 인덱스, 뷰 등 객체 각각에 따른 권한을 지정할 수 있으며, HTTPS통신을 통한 전송 데이터 암호화를 지원합니다.

다음은 복구과 이용입니다. WAL은 선행기입로그라는 뜻으로, 간단하게 이때까지 한 작업을 기록한 로그파일이라고 생각하시면 됩니다. 로그 아카이빙 및 열린 백업을 통해, 데이터베이스가 가동되는 중에도 특정 시점으로의 복구가 가능합니다. 또한 스트리밍 복제와 같은 실시간 복제도 지원하고 있습니다.

마지막으로 발전입니다. 진보하고 안정적인 오픈소스라고 할 수 있겠습니다. pg_upgrade라는 명령을 이용해 업그레이드가 가능하고, pgAdmin이란 GUI 툴을 제공함으로써 관리할 수 있습니다. 문서와 메뉴얼도 잘 되어 있지만 대부분 영어입니다.

`4) 내부 구조`

데이터베이스 내부 구조를 알아보겠습니다.

모든 객체의 집합인 클러스터가 제일 상위에 있고, 그 밑에 사용자 그룹, 데이터베이스, 테이블 스페이스로 나누어 집니다. 그리고 데이터베이스 하위에는 스키마가 있고, 스키마 안에 실제 테이블, 뷰, 시퀀스 등 객체가 포함되어 있습니다.

pgAdmin으로 보면 이런 구조입니다. 한 데이터베이스 내에 데이터베이스를 여러 개 만들 수 있고, 그 데이터베이스 내에 또 여러 개의 스키마를 만들 수 있습니다. 포스트그레스큐엘에서 스키마는 테이블의 집합이라고 할 수 있겠습니다. 같은 데이터베이스 내의 스키마끼리만 JOIN이 가능합니다.

주요 생성 명령은 다른 DBMS와 거의 동일합니다. 유저를 생성하고, 데이터베이스를 생성하고, 스키마를 생성합니다. 각 객체에 대한 조회는 pg_를 앞에 붙이면 되겠습니다.

`template`

데이터베이스 목록을 조회해보면 사용자가 생성한 테이터베이스 말고도 template이라는 데이터베이스가 보이실 겁니다. 이건 포스트그레스 내에 존재하는 기본 데이터베이스이며, template을 복제하는 방식으로 새로운 데이터베이스를 생성합니다. template1은 원하는 요소를 넣어 커스터마이징이 가능하고, template0은 초기화된 데이터베이스입니다. 기본값은 template1입니다.

`권한`

다음은 권한입니다. GRANT로 권한을 부여, REVOKE로 권한을 회수하면 되겠습니다. 검색, 수정이나 객체에 대한 각각의 권한을 설정할 수 있습니다.

pgAdmin에서 보면 이렇습니다. testuser 계정으로 접속했을 때, postgres계정 내의 테이블에 접근하면 에러 메세지가 출력됩니다.

`아키텍처`

다음은 아키텍처에 대해 알아보겠습니다.

이 그림은 크게 다섯 부분으로 나눌 수 있습니다. 첫째-포스트 마스터 데몬, 둘째-공유 메모리 영역, 셋째-백그라운드 프로세스, 넷째-저장 영역, 다섯째-백앤드 프로세스.

인터넷 주문을 예로 들어보겠습니다. 사용자들이 주문을 하면, 1)가장 먼저 포스트 마스터 데몬 프로세스가 시작되며 주문을 받습니다. 2)주문서들은 종류별로 메모리 영역에 쌓입니다. 3)백그라운드 프로세스는 뒤에서 대기하고 있다가, 자기가 맡은 영역에 쌓인 주문서들을 가져와서 주문이 올바른지 검증합니다. 4)검증이 완료되었으면, 주문 기록을 저장소에 저장합니다. 4)백엔드 프로세스는 주문 결과를 사용자들에게 알립니다. 주문이 완료되었다면 완료되었다고, 아니면 다시 주문하라는 메세지를 보여줍니다.

이걸 단순화하면 이런 그림이 되겠습니다. 인터페이스 라이브러리로 서버 연결을 요청하면 포스트마스터가 요청을 받아 백엔드 서버를 생성하고, 이 서버에서 쿼리 요청에 대한 응답을 하는 구조가 되겠습니다.

`세부 기능 및 제한`

세부 기능 및 제한입니다. 트랜잭션 내에 트랜잭션 설정이 가능하고, 세이브 포인트를 설정할 수 있습니다. 

(트랜잭션 설정 방법은 이렇습니다. BEGIN과 COMMIT 사이에 명령을 지정하면 됩니다.

SAVEPOINT는 특정 시점으로 돌아가는 지점을 설정하는 것을 뜻합니다. 이 예시를 보시면 세이브포인트가 BOB을 업데이터 하기 전에 설정되었으므로, BOB에 대한 수정은 취소됩니다.)

포스트그레스큐엘 저장소에 로그가 계속 쌓이기 때문에 로그 파일을 사용한 특정 시점으로 복구하는 것이 가능하고,

데이터베이스 서버를 중단하지 않고도 다중 백업, 동시 백업을 진행할 수 있습니다.

규칙 쿼리 시스템은 CRUD 작업을 마치 변수에 할당하는 것처럼 나만의 기능을 만드는 것을 의미합니다. 현재는 잘 사용하지 않기 때문에 넘어가겠습니다.

그리고 B트리, 해시 등 다양한 인덱스를 제공합니다. 인덱스에 대해선 밑에서 설명을 보강하도록 하겠습니다.

(MVCC 설명 앞에서 했음)

테이블 스페이스란 데이터베이스 객체가 저장될 수 있는 파일의 경로를 뜻합니다. 저장소 내 여러개의 데이터베이스를 생성할 수 있다 보니 각각 다른 경로를 지정하고 싶을 때 사용할 수 있는 기능입니다.

(테이블 스페이스를 생성하는 방법은 이렇고, 테이블 스페이스 생성 후 데이터베이스의 테이블 스페이스 경로를 지정할 수 있습니다.

테이블 스페이스가 지정된 데이터베이스에서 수정된 사항이 테이블 스페이스 경로에 이렇게 물리적으로 저장되는 것을 확인할 수 있습니다.

데이터베이스에 대한 테이블 스페이스를 검색하면 이렇게 목록이 출력됩니다.)

그리고 절차 언어 ~ 정렬 등 지원하고요,

다양한 데이터 타입도 지원합니다. 대표적으로 ARRAY가 있습니다. (테이블을 생성할 때 컬럼 타입 뒤에 브라켓 표기를 붙이면 배열형 컬럼이 됩니다. 데이터 삽입을 이런 식으로 하면, 아래와 같은 결과를 확인할 수 있습니다. 이런식으로 검색하면 컬럼의 첫 번째 데이터를 읽어올 수 있습니다.)

다음은 시퀀스입니다. 포스트그레스큐엘에선 시퀀스와 칼럼 타입, 기타 구문으로 자동 증가 기능을 제공합니다. (먼저 시퀀스 생성은 이렇습니다. 시퀀스를 생성하고, 테이블 생성 시 칼럼에 시퀀스를 매칭해 줍니다. 그리고 데이터를 삽입하고 조회하면 아래와 같은 결과를 확인할 수 있습니다.

SERIAL은 칼럼 타입이며, 기본키 지정을 함께 해 줘야 합니다. PK를 지정했기 때문에 중복이 발생하진 않겠지만, ID값을 강제로 입력할 수는 있습니다.

기타 구문으로 자동증가 기능을 구현할 수도 있습니다. ALWAYS와 BY DEFAULT의 차이점은, 중복 가능 여부에 있습니다. ALWAYS는 OVERRIDING SYSTEM VALUE라는 구문을 써서 강제로 중복이 가능하지만, DEFAULT는 기본적으로 중복이 허용됩니다.)

그리고 비동기 복제로 로그 쉬핑, 스트리밍 복제를 제공합니다. (먼저 복제의 필요성에 대해 말씀드리겠습니다. 대용량 데이터를 다루는 프로그램은 보통 운영 서버와 대기서버 여러 대로 이루어져 있습니다. 운영 서버가 장애로 멈추게 된다면 대기 서버가 대신해서 서비스를 제공해야 하기 때문입니다. 이 경우 운영 서버가 가지고 있는 데이터가 대기 서버에도 있어야 정상적인 서비스 제공이 가능합니다. 그래서 평소에 운영 서버의 데이터를 대기 서버로 복제해 놓아야 합니다. 다시 말해서, 이 복제를 위한 방식이 포스트그레스큐엘에선 로그 쉬핑, 스트리밍 복제라고 할 수 있겠습니다.

로그 쉬핑은 저장소에 저장된 WAL, 앞에서 말씀드렸던 선행 기입로그 파일을 다 쓴 후 다른 서버로 전달하는 것을 말합니다. 그리고 스트리밍 복제는 이름에서 알 수 있듯이 실시간으로 전달하는 것을 말합니다. 운영 서버와 대기 서버가 직접 연결되어 있으며, 즉시 대기 서버로 커밋된 트랜잭션을 반영합니다.)

다음은 PAGINATION 입니다. LIMIT, OFFSET을 통해 간편하게 페이지네이션을 구현할 수 있으며, 예시는 다음과 같습니다.

그리고 인증과 보안에 관한 것은 포스트그레스큐엘 설치 폴더 내 환경설정 파일에서 설정할 수 있습니다. (자세한 설정은 이 부분을 참고해주시기 바랍니다.)

포스트그레스큐엘은 HSOTRE라는 모듈을 사용해 키/값을 간편하게 저장할 수 있습니다. (먼저 활성화를 해 주시고, 이런 형태로 작성하시면 됩니다.

테이블을 생성할 때 칼럼에 적용해주시면 되고, 삽입은 이런 형태로 해 주시면 되겠습니다.)

마지막으로 테이블 상속입니다. 기존 테이블 형식을 상속하는 테이블을 만들 수 있습니다. (부모-자식 관계로 나뉘고, 생성 방식은 다음과 같습니다. 자식 테이블을 생성할 때 INHERITS 뒤에 상속받고자 하는 테이블 이름을 넣어주시며 됩니다. pgAdmin에서 보면 두 테이블의 상속 관계를 나타내주는 화살표를 확인할 수 있습니다.

자식테이블을 상속받는 또 다른 자식테이블을 만들 수 있으며, 그 경우에는 화살표가 이런 식으로 표기됩니다.

부모 테이블을 삭제하려면 자식 테이블도 함께 삭제해야 하며, CASCADE 명령을 사용하면 부모-자식 관계에 있는 테이블을 한꺼번에 삭제할 수 있습니다.)

`제한사항`

포스트그레스큐엘의 각 객체에 대한 제한 용량은 다음과 같습니다.

`경쟁 제품들과의 비교`

결론적으로 포스트그레스큐엘은 대용량, 복잡한 기능 구현에 용이하고, 상용 비용이 적으며, 메뉴얼이 잘 되어 있는 편이라고 할 수 있겠습니다.

### ORACLE vs PostgreSQL

그렇다면 가장 많이 사용되는 오라클과는 어떤 점이 다른지 알아보겠습니다.

쭉 읽어보시면 비슷한 점이 많다는 것을 알 수 있으실 겁니다. 그 중 파티셔닝 방법에 대해 자세히 알아보겠습니다. 결론적으로 오라클, 포스트그레스큐엘 모두 테이블 파티셔닝을 제공합니다.

(파티션이란 하나의 테이블을 특정 분할 기준에 따라 행들을 나눈 것을 뜻합니다. 먼저 오라클은 레인지, 리스트, 해시 파티셔닝을 지원합니다. 레인지는 날짜와 같은 범위 단위로 나누고, 리스트는 특정 컬럼 값을 기준으로, 해시는 해시 함수에 의해 나누는 방법입니다. 

포스트그레스큐엘에서도 동일하게 레인지, 리스트, 해시 파티셔닝을 지원합니다. 10 버전 이전에는 상속관계에 트리거를 거는 번거로운 작업을 거쳐야 했다면, 이후에는 단순하게 바뀌었습니다.

먼저 부모 테이블을 생성하고 파티션 설정과 방법을 지정해줍니다. 그리고 자식 테이블을 생성하며 파티션 이름과 범위 값을 설정해 줍니다.

그럼 이런 식으로 한 테이블에 대한 파티션이 나누어 지는 것을 확인할 수 있겠습니다.)

### 설치

이제 실제로 포스트그레스큐엘을 사용해 보겠습니다. 해당 링크로 들어가면 설치 방법에 대해 자세하게 나와 있습니다.

### 환경 변수 설정

설치가 끝났으면 환경 변수를 설정합니다. shell 환경에서 포스트그레스큐엘을 사용할 때 필요하니 반드시 해 주셔야 합니다.

### 접속

shell, 명령 프롬프트, pgAdmin 모두 사용 가능합니다. 사용자 계정과 비밀번호를 입력 후 접속할 수 있습니다.

### CRUD

이제 쿼리를 작성해 보겠습니다. 아래 표는 shell 명령어로, shell을 사용할 때 활용하면 되겠습니다.

CREATE, SELECT, UPDATE, DELETE 명령은 보통 DBMS에서 사용하는 형식과 완전히 동일합니다. 여기서는 쉘 사용에 대한 예만 보여드리고 간단히 넘어가겠습니다.

먼저 테이블 생성입니다. shell에 차례대로 한줄씩 입력 후, 세미콜론을 쓰면 구문이 실행이 됩니다. 오류가 발생했을 시 \e 명령을 입력하면 메모장으로 쿼리 수정이 가능합니다.

테이블을 생성하고 pgAdmin에서 확인하면 이런 모습이 되겠습니다.

그리고 테이블 복사는 이런 식으로 하시면 됩니다. 이건 단순한 칼럼과 타입 복사이므로 상속과는 관계가 없습니다.

나머지는 넘어가겠습니다.

### 자료형

포스트그레스큐엘에서 제공하는 데이터 타입들입니다. 한 번 읽어 보시고, JSON자료형에 대해서만 짚고 넘어가겠습니다. 말 그대로 JSON형식 자료형이며, JSON과 JSONB로 나누어집니다. JSON은 삽입 그대로 값을 저장합니다. JSONB은 문자열 사이의 공백을 제거하지만, 키의 순서를 보장하지 않아서, 결과를 보면 키 순서가 바뀌어 있는 것을 확인할 수 있습니다.

데이터를 삽입하면 이런 식으로 출력되는 것을 보실 수 있습니다.

### 활용

`연산자 및 함수`

오라클과 비교해서 연산자와 함수가 어떻게 다른지 알아보겠습니다.

SELECT FROM DUAL은 그냥 SELECT로 쓸 수 있습니다.

그리고 시퀀스는 이런 식으로 순서가 바뀌었습니다.

형변환은 CAST 하나로 손쉽게 가능합니다. (이런 식으로 AS와 콜론 두개를 쓰는 방식으로 형변환하시면 됩니다.)

치환을 처리하는 기능은 콜레스라는 함수가 담당하고 있으며, NULLIF기능은 둘 다 같습니다.

날짜와 시간 함수는 서로 차이점이 많습니다. (날짜 시간 타입을 정리해놨으니 읽어보시면 되겠고, date_trunc()에 대해서만 짚고 넘어가겠습니다. date_trunc()는 필요없는 날짜를 제거하는 함수입니다. 예시를 보시면 현재시간 기준으로 '월'까지만 남기고 모두 제거한 결과가 이렇게 나왔습니다. 시간은 0값이 되었지만 일자는 1입니다. 이걸 보시면 필요없는 날짜를 제거하기 보다는 초기화한다고 보면 되겠습니다.)

포스트그레스큐엘에는 디코드가 없고 모두 CASE로 표현해 주셔야 합니다.

`그 외 연산자 및 함수`

그 외 연산자 및 함수는 몇 개만 알아보겠습니다.

먼저 array_append()는 배열 뒤에 원소를 추가하는 함수입니다. 예시를 보시면 이런 형식으로 배열에 원소를 추가할 수 있습니다. prepend는 배열 앞에 원소를 추가하고, remove()는 지우고, replace()는 대체, cat()은 배열을 병합합니다.

그리고 json_build_object()는 json오브젝트를 생성합니다. json_build_array()는 json배열을 생성합니다.

`조인`

다음은 조인입니다. 조인의 종류에는 레프트 조인, 라이트 조인, 이너 조인, 풀 아우터 조인이 있습니다. 그냥 JOIN이라는 쿼리만 썼을 때 기본값은 이너조인입니다.

이너조인은 이런 식으로 3가지로 표현할 수 있습니다. 예시는 앞에서 나온 데이터베이스에 대한 테이블 스페이스 매칭하기 입니다. 3가지 모두 성능상 차이는 없습니다.

조인 구조를 시각적으로 확인할 수 있는 방법이 있습니다. SHELL에서는 쿼리 맨 앞에 EXPLAIN을 추가하면 되고, pgAdmin에서는 이 버튼을 누르면 시각적으로 확인이 가능합니다.

나머지 조인은 오라클과 완전히 같으므로 생략하겠습니다.

`인덱스`

포스트그레스큐엘에서 제공하는 인덱스인 B-TREE인덱스, 해시 인덱스, GIN인덱스에 대해 알아보겠습니다.

인덱스는 단일 혹은 다수의 컬럼을 효율적으로 검색하게 해 주는 기능입니다. 

`B-Tree 인덱스`

옵션을 지정하지 않으면 기본값으로 B-Tree인덱스가 설정됩니다. 화면에 보이는 것처럼 연결된 노드 키들이 부모-자식 형태로 정렬되어 있습니다. 이런 식으로 노드를 거슬러 가는 방식으로 검색합니다. 

인덱스를 생성하는 쿼리는 이렇습니다. 컬럼 값의 수에 따라 단일, 복합 칼럼 인덱스를 설정할 수 있고, 조건에 따라 부분 인덱스를 설정할 수 있습니다. 

`해시 인덱스`

해시화 함수를 통해 값을 변형한 것이 해시 인덱스입니다. 메모리와 속도 면에서 좋지만, 값이 변형되기 때문에 연산이나 비교가 불가능합니다.

`GIN 인덱스`

진 인덱스는 Full Text Search에 주로 사용되는 인덱스입니다. 긴 문자열이 들어가는 칼럼에 적합하겠습니다. 칼럼의 값을 쪼갠 뒤 그 속에서 LIKE와 같은 검색을 할 수 있기 때문에, 정확도를 요하는 검색에 적합하다고 할 수 있습니다.

GIN인덱스 활용에 대한 예시입니다. GIN인덱스는 대용량 데이터가 저장되어 있는 칼럼에 주로 적용하기 때문에, TO_TSVECTOR라는 함수를 써서 전처리 과정을 해 주어야 검색 효율을 높일 수 있습니다.

`뷰`

다음은 뷰에 대해 설명하겠습니다. 뷰는 실제하지 않는 가상의 테이블입니다. 뷰는 참조한 테이블과 연결되고, 뷰가 존재하는 테이블을 삭제하려면 뷰를 삭제하거나 CASCADE 명령을 사용해야 합니다. CASCADE를 사용하지 않고 그냥 테이블을 삭제하면 아래와 같은 에러 메세지가 출력되는 것을 확인할 수 있습니다.

### 프로시저 함수 & 트리거

포스트그레스큐엘에서는 여러가지 종류의 언어로 프로시저 함수를 만들 수 있습니다. 먼저 CREATE LANUAGE 라는 명령어로 사용하고자 하는 언어를 설치한 뒤 사용하시면 되겠습니다.

프로시저 형식에 대해 알아보겠습니다. 오라클과 거의 비슷하지만 $$가 들어가는 것이 차이점입니다.

함수를 생성하거나 대체하고, 함수의 이름을 지정하고, 파라미터를 기재하고, 리턴 타입을 설정합니다. BEGIN과 END사이엔 실제 동작시킬 기능을 구현하고, 마지막으로 사용 언어를 기재해 줍니다. 예시를 보겠습니다.

두 정수 a, b의 곱을 리턴하는 프로시저를 만들겠습니다. mul이란 이름의 함수를 만들고, 매개변수로 정수 a, b를 받습니다. 리턴 타입은 정수고, 구현부에 a와 b의 곱을 리턴합니다. 언어는 plPGsql을 사용했습니다. 실행하면 이렇게 결과가 나오는 것을 알 수 있습니다.

단순 테스트용 출력을 구현할 수도 있습니다. 이런 식으로 변수를 정의하고, 조건문을 구현합니다. RAISE NOTICE는 단순 메세지로 출력되는 것입니다. 실행 결과는 다음과 같이 나오는 것을 확인할 수 있습니다.

마지막으로 반복문에 대한 예시를 알아보겠습니다.  adder이라는 프로시저 함수를 만들고, n이라는 정수형 매개변수를 받습니다. 리턴 타입은 정수로 지정하고, result라는 변수를 지정하고 0으로 초기화합니다. 구현부에 루프 조건을 기재하고, 반복문이 실행될 동안 i의 값을 메세지에 출력하고, result의 값을 1씩 증가시킵니다. 그리고 i가 홀수, 짝수냐에 따라 info3테이블에 조건에 맞는 값을 삽입합니다. 반복문이 끝나면 result값을 리턴합니다. 마지막으로 언어는 plpgsql이 사용되었음을 알려줍니다. 실행 결과를 보시면 RAISE NOTICE로 출력된 i값, info3에 삽입된 데이터의 값, 리턴된 result의 값을 확인할 수 있습니다.

`트리거`

트리거는 어떤 행동이나 작업을 했을 때, 미리 저장해 놓은 작업이 자동으로 실행되도록 하는 것입니다.

구독자가 구독 버튼을 누르면 자동으로 구독자 수가 갱신되는 시스템을 예로 들어보겠습니다.

먼저 구독자 테이블을 생성합니다. 그리고 구독자 수 테이블을 생성하고 데이터를 0으로 초기화합니다.

그 다음 트리거를 생성합니다. 프로시저 함수 형식에 리턴 형식만 TRIGGER로 설정하고, 구현부에는 수정 대상 테이블에서 일어나는 작업을 작성해 주시면 되겠습니다.

트리거를 생성 후에는 실행 단계를 거쳐야 합니다. 구독자 테이블에서 구독자 데이터가 삽입되었을 때 트리거를 실행해야 하므로 AFTER INSERT를 사용합니다. 그리고 트리거를 수행하는 코드와 실행할 함수 sub_like()를 입력해 주면 트리거 설정이 완료됩니다.

구독자 테이블에 데이터를 입력한 후 구독자 수 테이블을 확인하면 트리거가 잘 작동하는 것을 확인할 수 있습니다. 이상으로 트리거에 대한 설명이 완료되었습니다.

제가 준비한 자료는 여기까지입니다. 질문이 있으시면 해 주시기 바랍니다.
